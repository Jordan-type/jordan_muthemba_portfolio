---
title: Clean Code In Solidity Structuring The Token2024 Contract For Readability Functionality
description: A guide to common code snippets for interacting with Ethereum smart contracts using Clean Code In Solidity Structurin...
date: '2024-11-01'
lang: en
tags:
- ethers.js
- smartcontract
- cheat-sheet
- javascript
category: cheat-sheet
---

import CodeSnippet from '@/components/mdx/Code';
import { DnD, Dont, Do } from '@/components/mdx/TIL';
import { QuickView } from '@/components/mdx/Link';
import CodeGroup from '@/components/mdx/CodeGroup';

## âœ¨ Clean Code in Solidity: Structuring the `Token2024` Contract for Readability, Functionality, Arrays, and Enums

[![Jordan Type](https://miro.medium.com/v2/resize:fill:88:88/0*-BxK6NvbOEXZ038-.)

](https://jordanmuthemba.medium.com/?source=post_page---byline--8f266c1f0172--------------------------------)[![CoinsBench](https://miro.medium.com/v2/resize:fill:48:48/1*cxyieQYifV8lgCQjIXZ6ZQ.jpeg)

](https://coinsbench.com/?source=post_page---byline--8f266c1f0172--------------------------------)

[Jordan Type](https://jordanmuthemba.medium.com/?source=post_page---byline--8f266c1f0172--------------------------------)

Â·

[Follow](https://medium.com/m/signin?actionUrl=https%3A%2F%2Fmedium.com%2F_%2Fsubscribe%2Fuser%2Fc405a7ae1c25&operation=register&redirect=https%3A%2F%2Fcoinsbench.com%2Fclean-code-in-solidity-structuring-the-token2024-contract-for-readability-functionality-8f266c1f0172&user=Jordan+Type&userId=c405a7ae1c25&source=post_page-c405a7ae1c25--byline--8f266c1f0172---------------------post_header-----------)

Published in[CoinsBench](https://coinsbench.com/?source=post_page---byline--8f266c1f0172--------------------------------)Â·4 min readÂ·Nov 1, 2024


In Solidity, as in any programming language, clean code principles ensure that code is easy to read, maintain, and scale. For smart contracts ðŸ’° â€” which often handle valuable assets and complex business logic â€” clean, understandable code is critical. This article dives into the `Token2024` Solidity contract, exploring arrays and enums, and how to follow clean code principles while implementing them. ðŸš€

**Key Components of the** `**Token2024**` **Contract**  
The `Token2024` contract includes functions that handle dynamic and fixed-size arrays, plus an additional contract demonstrating enums. Letâ€™s dive into applying clean code principles in Solidity using this contract as an example. ðŸ§‘â€ðŸ’»

1\. **ðŸ“š Code Clarity Through Documentation**

A well-documented contract reduces ambiguity and clarifies each functionâ€™s purpose and expected behavior. Hereâ€™s an example of adding high-level comments to explain the contract, functions, and major logic sections:

```js
// SPDX-License-Identifier: MIT  
// Compatible with OpenZeppelin Contracts ^5.0.0  
pragma solidity ^0.8.22;  
  
/\*\*  
 \* @title Token2024  
 \* @dev Implements basic array operations and state management for arrays and enums.  
 \*/  
contract Token2024 {
```

Each contract should describe its primary role ðŸ“„, including any key compatibility information.

2\. **ðŸ–Šï¸ Descriptive Naming Conventions  
**Names should convey purpose. For example, renaming `arr1` to `initialArray` provides more context, while `_array` in the `get` function could be `index` for clarity:

```js
 uint256\[\] public arr; // Dynamic array  
    uint256\[\] public initialArray = \[1, 2, 3\]; // Initialized dynamic array  
  
    uint256\[2\] public fixedArray; // Fixed-size array with two elements
```

3\. **ðŸ”„ Array Operations in Solidity**

The `Token2024` contract uses basic array functions to push, remove, and retrieve elements. Hereâ€™s how to refine these for better readability and functionality.

```js
 /\*\*  
     \* @dev Returns the element at the specified index of \`arr\`.  
     \* @param index Position within the array.  
     \* @return Element at the provided index.  
     \*/  
    function get(uint256 index) public view returns (uint256) {  
        return arr\[index\];  
    }  
  
    /\*\*  
     \* @dev Returns the entire array \`arr\`.  
     \* @return The entire dynamic array.  
     \*/  
    function getEntireArray() public view returns (uint256\[\] memory) {  
        return arr;  
    }
```

4\. **Refining Data Mutation Functions ðŸ”¨  
**Functions that change the contractâ€™s state, such as `pushData`, `removeData`, and `remove`, should specify the action they perform, their effect on `arr`, and handle potential edge cases.

```js
 /\*\*  
     \* @dev Adds a new element to the end of \`arr\`.  
     \* @param num Value to be added to the array.  
     \*/  
    function pushData(uint256 num) public {  
        arr.push(num);  
    }  
  
    /\*\*  
     \* @dev Removes the last element from \`arr\`.  
     \* Fails if \`arr\` is empty.  
     \*/  
    function removeData() public {  
        require(arr.length > 0, "Array is already empty."); // âœ… Error handling  
        arr.pop();  
    }  
  
    /\*\*  
     \* @dev Removes the element at a specific index in \`arr\` by setting it to zero.  
     \* @param index Position in array to be removed.  
     \*/  
    function remove(uint256 index) public {  
        require(index < arr.length, "Index out of bounds."); // âœ… Check bounds  
        delete arr\[index\];  
    }
```

Adding `require` statements ensures safe and predictable actions and protects the contract from errors. ðŸ›¡ï¸

5\. **ðŸ“Š Enumerations (Enums) for State Management**

Enums define a set of possible values for a variable, making state-based logic more readable and safer. Here, `Enum` manages delivery statuses. Using enums avoids magic values and improves readability, making state management straightforward.

```js
// Enum to manage delivery states  
contract Enum {  
    enum Status {  
        Pending,   
        Shipped,   
        Rejected,  
        Completed  
    }  
  
    Status public status; // Default state is \`Pending\` (index 0)  
  
    /\*\*  
     \* @dev Returns the current status.  
     \* @return Current status of the enum.  
     \*/  
    function get() public view returns (Status) {  
        return status;  
    }  
  
    /\*\*  
     \* @dev Sets a new status.  
     \* @param newStatus New status to update to.  
     \*/  
    function set(Status newStatus) public {  
        status = newStatus;  
    }  
}
```

Using enums as above provides clear state management, allowing easy reference to possible statuses ðŸ“Œ. Each status is represented by an integer starting from zero, making storage efficient and improving readability.

6\. **ðŸ“ Additional Tips for Clean Code**

*   **Remove Unnecessary Code**: Eliminate redundant code or irrelevant comments (like `DIY`) that donâ€™t add clarity.
*   **Follow Naming Conventions**: Use descriptive names (e.g., `pushData` vs. `addElement`).
*   **Structure for Readability**: Group related functions and provide summaries for sections.
*   **Error Handling**: Use `require` and `revert` for errors with meaningful messages, ensuring safe execution.

ðŸŽ‰ Final Thoughts

Writing clean code in Solidity is all about simplicity, clarity, and readability. By following clean code principles, we create safe ðŸ›¡ï¸, robust, and easy contracts for others to understand â€” an essential approach in blockchain development.
